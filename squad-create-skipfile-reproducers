#!/usr/bin/python3
# -*- coding: utf-8 -*-
# vim: set ts=4
#
# Copyright 2023-present Linaro Limited
#
# SPDX-License-Identifier: MIT

import argparse
import logging
import os
import sys
import time

import yaml
from squad_client.core.api import SquadApi

import squadutilslib

squad_host_url = "https://qa-reports.linaro.org/"
SquadApi.configure(cache=3600, url=os.getenv("SQUAD_HOST", squad_host_url))

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

linux_stable_rc_branches = {
    "linux-4.14.y": "linux-stable-rc",
    "linux-4.19.y": "linux-stable-rc",
    "linux-5.4.y": "linux-stable-rc",
    "linux-5.10.y": "linux-stable-rc",
    "linux-5.15.y": "linux-stable-rc",
    "linux-6.1.y": "linux-stable-rc",
    "linux-6.2.y": "linux-stable-rc",
}

linux_mainline_next_branches = {
    "linux-mainline": "master",
    "linux-next": "master",
}


def supported_branch_names():
    return list(linux_stable_rc_branches) + list(linux_mainline_next_branches)


def look_up_project_by_branch(branch_name):
    if branch_name in linux_stable_rc_branches:
        return f"{linux_stable_rc_branches[branch_name]}-{branch_name}"
    elif branch_name in linux_mainline_next_branches:
        return f"{branch_name}-{linux_mainline_next_branches[branch_name]}"
    else:
        raise Exception(
            "Unknown branch name {0}. \nSupported branch names: \n\t- {1}".format(
                branch_name, "\n\t- ".join(supported_branch_names())
            )
        )


def parse_args(raw_args):
    parser = argparse.ArgumentParser(description="Produce TuxRun or TuxPlan reproducers for the LTP skipfile.")

    parser.add_argument(
        "--group",
        required=True,
        help="The name of the SQUAD group.",
    )

    parser.add_argument(
        "--branches",
        required=False,
        default=supported_branch_names(),
        nargs="+",
        help="A list of SQUAD branches to be tested.",
    )

    parser.add_argument(
        "--device-names",
        required=False,
        default=["qemu-armv7", "qemu-arm64", "qemu-i386", "qemu-x86_64"],
        nargs="+",
        help="The list of device names (for example, qemu-arm64).",
    )

    parser.add_argument(
        "--build-names",
        required=False,
        default=["gcc-12-lkftconfig", "gcc-\d\d-lkftconfig"],
        nargs="+",
        help="The list of accepted build names (for example, gcc-12-lkftconfig). Regex is supported.",
    )
    parser.add_argument(
        "--suite-name",
        required=False,
        default="ltp-syscalls",
        help="The suite name to grab a reproducer for.",
    )

    parser.add_argument(
        "--allow-unfinished",
        action="store_true",
        default=False,
        help="Allow fetching of reproducers where the build is marked as unfinished.",
    )

    parser.add_argument(
        "--local",
        action="store_true",
        default=False,
        help="Create a TuxRun reproducer when updating rather than a TuxPlan.",
    )

    parser.add_argument(
        "--debug",
        action="store_true",
        default=False,
        help="Display debug messages.",
    )

    return parser.parse_args(raw_args)


def run(raw_args=None):
    start = time.time()
    args = parse_args(raw_args)

    skipfile_url = (
        "https://raw.githubusercontent.com/Linaro/test-definitions/master/automated/linux/ltp/skipfile-lkft.yaml"
    )

    skipfile = squadutilslib.get_file(skipfile_url)

    reason_list = []

    with open(skipfile) as f:
        reasons = yaml.load(f, Loader=yaml.FullLoader)
    for reason in reasons["skiplist"]:
        if reason["boards"] == "all" or "all" in reason["boards"]:
            if reason["branches"] == "all" or "all" in reason["branches"]:
                projects = [look_up_project_by_branch(branch) for branch in args.branches]
            else:
                for branch_name in reason["branches"]:
                    if branch_name in args.branches:
                        projects.append(look_up_project_by_branch(branch_name))
                    else:
                        logger.warning(
                            f"Branch name {branch_name} is not supported by this script or was not provided as an argument in --branches. Skipping."
                        )

            # Create a cleaned version of the skipfile reason that is easier to
            # work with
            cleaned_reason = {}
            if isinstance(reason["tests"], list):
                cleaned_reason["tests"] = reason["tests"]
            else:
                cleaned_reason["tests"] = [reason["tests"]]

            cleaned_reason["projects"] = projects

            reason_list.append(cleaned_reason)

    for project in [look_up_project_by_branch(project) for project in args.branches]:
        for device in args.device_names:
            try:
                tuxrun_reproducer_file = squadutilslib.find_reproducer(
                    args.group,
                    project,
                    device,
                    args.debug,
                    args.build_names,
                    args.suite_name,
                    args.allow_unfinished,
                )
            except squadutilslib.ReproducerNotFound:
                warning = f"No reproducer could be found for {args.group} {project} {device} {args.build_names}"
                logger.warning(warning)
                with open("error.log", "a+") as errorlog:
                    errorlog.write(warning)
                    errorlog.write("\n")
                continue
            for reason in reason_list:
                if project in reason["projects"]:
                    custom_command = squadutilslib.create_ltp_custom_command(tests=reason["tests"])
                    if args.local:
                        reproducer = squadutilslib.create_ltp_tuxrun_reproducer(
                            tuxrun_reproducer_file, args.suite_name, custom_command
                        )
                    else:
                        reproducer = squadutilslib.create_ltp_tuxsuite_plan_reproducer(
                            tuxrun_reproducer_file, custom_command
                        )
                    logger.debug(reproducer)

    logger.info("Finished creating skipfile reproducers.")
    logger.info(f"Took {time.time() - start}s")


if __name__ == "__main__":
    sys.exit(run())
