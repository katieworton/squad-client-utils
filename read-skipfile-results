#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# vim: set ts=4
#
# Copyright 2023-present Linaro Limited
#
# SPDX-License-Identifier: MIT

from argparse import ArgumentParser
from copy import deepcopy
from datetime import datetime
from json import load
from logging import DEBUG, INFO, basicConfig, getLogger
from os import chdir, environ, getenv, path, rename
from pathlib import Path
from re import findall, sub

from git import Repo
from github import Github
from ruamel.yaml import YAML
from squad_client.core.api import SquadApi
from squad_client.core.models import Environment, Squad, TestRun
from squad_client.utils import first, getid

from squadutilslib import get_file


def parse_args(raw_args):
    parser = ArgumentParser(description="Read results and update skipfile")

    parser.add_argument(
        "--group-name",
        required=True,
    )

    parser.add_argument(
        "--run-count",
        required=True,
        type=int,
        help="The number of runs performed.",
    )

    parser.add_argument(
        "--builds-file",
        required=False,
        default="builds_for_skipfile_runs.txt",
        help="File containing the list of SQUAD build names",
    )

    parser.add_argument(
        "--debug",
        required=False,
        action="store_true",
        default=False,
        help="Display debug messages.",
    )

    parser.add_argument(
        "--github-token",
        required=False,
        default="GITHUB_ACCESS_TOKEN",
        help="The name of the environment variable containing the Github API token.",
    )

    parser.add_argument(
        "--project_name",
        required=False,
        default="skipfile-testing",
    )

    parser.add_argument(
        "--repo-path",
        required=False,
        default="test-definitions",
        help="The path of the test-definitions repo.",
    )

    parser.add_argument(
        "--sha-filename",
        required=False,
        default="sha_list.csv",
        help="Name for the file containing the build SHA.",
    )

    parser.add_argument(
        "--skipfile",
        required=False,
        default="automated/linux/ltp/skipfile-lkft.yaml",
    )

    parser.add_argument(
        "--squad-host",
        required=False,
        default="https://qa-reports.linaro.org/",
    )

    parser.add_argument(
        "--username",
        required=False,
        default="katieworton",
        help="The username for the test-definitions repo",
    )

    return parser.parse_args(raw_args)


def delete_skiplist_entry(skipfile, url):
    """
    Delete an entry from the skiplist (for example, when a bug has been fixed)
    """
    skipfile["skiplist"] = [test for test in skipfile["skiplist"] if url != test["url"]]


basicConfig(level=INFO)
logger = getLogger(__name__)


def create_commit(repo, summary, message):
    repo.git.commit(
        "-m",
        f"{summary}\n\n{message}",
    )


def create_commit_push_pr(
    token, local_repo, github_repo, username, summary, message, base, head
):
    if len(summary) > 50:
        # Truncate the commit summary to < 50 characters for git commit
        truncated_summary = summary[:47] + "..."
    else:
        truncated_summary = summary

    create_commit(local_repo, truncated_summary, message)

    local_repo.create_head(head)

    local_repo.git.push(
        f"https://{username}:{token}@github.com/{username}/test-definitions",
        f"{head}",
        "-f",
    )

    title = f"[automated] {summary}"
    body = f"""[automated] {message}"""

    pr = github_repo.create_pull(
        title=title,
        body=body,
        head=head,
        base=base,
    )
    logger.debug(f"PR created {pr}")


def run(raw_args=None):
    args = parse_args(raw_args)
    SquadApi.configure(cache=3600, url=getenv("SQUAD_HOST", args.squad_host))

    if args.debug:
        logger.setLevel(level=DEBUG)

    # log date
    date_str = f"{datetime.now():%Y-%m-%d}"

    builds = args.builds_file
    group = Squad().group(args.group_name)
    project = group.project(args.project_name)

    builds_list_file = open(builds, "r")
    squad_builds = builds_list_file.readlines()

    results_file_name = "results.csv"
    results_file = open(results_file_name, "w+")

    skipfile_name = args.skipfile

    # Set up Github access
    username = args.username
    my_api_key = environ.get(args.github_token)
    g = Github(my_api_key)

    # Check test-definitions exists
    if not path.isdir(args.repo_path):
        exit(1)

    repo = Repo(args.repo_path)

    # Move SHA file to test-definitions for easier access
    rename(args.sha_filename, f"{args.repo_path}/{args.sha_filename}")
    chdir(args.repo_path)

    # Any hangs will not produce a result - so the results file will contain
    # the results for only non-hanging tests.
    test_rerun_count = args.run_count
    build_scores = dict()
    patch_count = 0

    # Read skipfile
    skipfile_txt = Path(skipfile_name).read_text()
    yaml = YAML()
    yaml.indent(mapping=2, sequence=4, offset=2)
    skipfile = yaml.load(skipfile_txt)

    # fix formatting and create a commit for it
    with open(skipfile_name, "w") as output_yaml:
        yaml.dump(skipfile, output_yaml)

    repo.git.add(u=True)

    github_repo = g.get_repo(f"{username}/test-definitions")

    # If there are any formatting updates, make these
    if repo.index.diff("HEAD"):
        summary = "Skipfile formatting updates"
        message = "Clean up skipfile formatting."
        base = "master"
        head = f"formatting-update-{date_str}-{patch_count}"

        logger.debug([str(b.name) for b in github_repo.get_branches()])

        create_commit_push_pr(
            my_api_key, repo, github_repo, username, summary, message, base, head
        )
        logger.debug(f"Pushed to {head}")

        # Increment the patch counter
        patch_count += 1

    # Loop through and count the non-hangs
    for build_name in squad_builds:
        build_scores[build_name] = dict()
        pass_counts = build_scores[build_name]
        logger.info(f"SQUAD build name {build_name}")
        # fetch the SHA info
        sha_info = ""
        with open(args.sha_filename, "r") as file:
            for line in file:
                # for each non-empty line, filter SHAs
                if line.strip():
                    reproducer_script_name, device, sha = line.split(",")
                    if reproducer_script_name in build_name:
                        sha_info += f"\n- {device}: {sha}"

        if build_name != "":
            # Get the build whose name matches the build name from our list
            build = first(project.builds(version=build_name))
            # Look at the tests for that build
            tests = build.tests()
            # Check each of the tests
            for test in tests.values():
                # We only care about the custom commands not boot
                if "commands" in test.name:
                    env = Environment(getid(test.environment))
                    testrun = TestRun(getid(test.test_run))
                    get_file(testrun.job_url + "/results")
                    reproducer = open("results", "r")
                    results_json = load(reproducer)
                    try:
                        # gets the name of the custom command
                        name = (
                            results_json["lava"]["commands"]["repository"]["run"][
                                "steps"
                            ][0]
                            .split(" ")[1]
                            .strip()
                        )
                        # Gets the result if the test did not time out
                        overall_result = results_json["commands"][name]["result"]
                        # Get names of tests run and split it into a list
                        tests = (
                            results_json["lava"]["commands"]["repository"]["run"][
                                "steps"
                            ][0]
                            .split("cd /opt/ltp && ./runltp -s ")[1]
                            .strip()
                        )
                        tests = sub("'", "", tests)
                        tests = sub('"', "", tests).split(" ")

                        # get device type from reproducer
                        get_file(testrun.job_url + "/reproducer")
                        reproducer = Path("reproducer").read_text(encoding="utf-8")
                        device = findall("--device (\S+)", reproducer)[0]
                        tests_string = ",".join(sorted(tests))
                        if tests_string in pass_counts:
                            if device in pass_counts[tests_string]["count"]:
                                pass_counts[tests_string]["count"][device] += 1
                            else:
                                pass_counts[tests_string][device] = dict()
                                pass_counts[tests_string]["count"][device] = 1
                                pass_counts[tests_string]["test_list"] = tests
                        else:
                            pass_counts[tests_string] = dict()
                            pass_counts[tests_string]["count"] = dict()
                            pass_counts[tests_string]["count"][device] = 1
                            pass_counts[tests_string]["test_list"] = tests

                    except KeyError:
                        overall_result = "result not found - investigate"

                    # Get runtime
                    try:
                        time = results_json["lava"]["commands"]["duration"]
                    except KeyError:
                        time = "time not found"
                    # Write results to CSV
                    results_file.write(
                        f"{test.short_name},{testrun.job_url},{env.slug},{time},{overall_result}\n"
                    )

                    logger.debug(f"Results saved to {results_file_name}")

    # loop through the builds/branches and decide what to remove

    tests = ""
    update = False
    removed_devices = ""
    for build_name, build_values in build_scores.items():
        # test_name:
        #     count: device: int
        #     test_list: list
        for test_name, test_values in build_values.items():
            # If all tests passed on this device, remove device from skipfile
            if test_values["count"][device] == test_rerun_count:
                new_skiplist = []
                for skipitem in skipfile["skiplist"]:
                    # search for entry
                    tests = test_values["test_list"]
                    # If the skipfile entry isn't a match, don't change it
                    if set(tests).difference(set(skipitem["tests"])):
                        new_skiplist.append(skipitem)
                    # If the skipfile entry matches the tests, remove the board
                    else:
                        # remove device
                        new_skipitem = deepcopy(skipitem)
                        if isinstance(new_skipitem["boards"], list):
                            if device in new_skipitem["boards"]:
                                new_skipitem["boards"].remove(device)
                                removed_devices += f"\n- {device}"
                                update = True
                            new_skiplist.append(new_skipitem)

            # If there is an update to skipfile for current test
            if update:
                skipfile["skiplist"] = new_skiplist

                # if there are changes, update skipfile
                # Produce skipfile update
                with open(skipfile_name, "w") as output_yaml:
                    yaml.dump(skipfile, output_yaml)

                # make updates and create a commit for it
                with open(skipfile_name, "w") as output_yaml:
                    yaml.dump(skipfile, output_yaml)

                repo.git.add(u=True)
                tests_string = ",".join(tests)
                tests_bulleted_string = "\n- " + "\n- ".join(tests)

                summary = f"automated: linux: ltp: skipfile: remove {tests_string}"

                message = (
                    f"Updates to skipfile to remove:\n{tests_bulleted_string}.\n\n"
                    + f"Test were shown to pass/fail rather than hang do not need to be skipped.\n\n"
                    + f"Remove for devices:\n{removed_devices}\n\n"
                    + f"Tests run {test_rerun_count} time(s).\n\n"
                    + f"Tested on:\n{sha_info}"
                )
                base = "master"
                head = f"skipfile-update-{date_str}-{patch_count}"

                create_commit_push_pr(
                    my_api_key,
                    repo,
                    github_repo,
                    username,
                    summary,
                    message,
                    base,
                    head,
                )
                logger.debug(f"Pushed to {head}")

                patch_count += 1
                update = False

    return 0


if __name__ == "__main__":
    exit(run())
